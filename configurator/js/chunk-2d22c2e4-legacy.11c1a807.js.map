{"version":3,"sources":["webpack:///./src/configurator/embedding/message-handler.ts"],"names":["MessageHandler","side","incomingMessageBus","outgoingMessageBus","messageExecution","_outgoingMessageBus","_execMessage","this","_side","_incomingMessageBus","addEventListener","_handleMessage","bind","fun","message","args","Promise","resolve","reject","messageChannel","MessageChannel","port1","onmessage","event","data","close","port2","Error","response","JSON","parse","e","_prepareError","error","undefined","result","command","stringify","postMessage","receiver","ports","Array","isArray","length","execResult","then","console"],"mappings":"gHAwBA,sDAAM,MAAOA,EAMX,YAAYC,EAAyBC,EAAwCC,EAAkDC,GAHvH,KAAAC,oBAAoD,KACpD,KAAAC,aAA2C,KAGjDC,KAAKC,MAAQP,EACbM,KAAKE,oBAAsBP,EAC3BK,KAAKF,oBAAsBF,EAC3BI,KAAKD,aAAeF,EACpBG,KAAKE,oBAAoBC,iBAAiB,UAAWH,KAAKI,eAAeC,KAAKL,OAGzE,sBAAsBJ,GAC3BI,KAAKF,oBAAsBF,EAGtB,oBAAoBU,GACzBN,KAAKD,aAAeO,EAGf,YAAYC,EAAiBC,EAAc,IAChD,OAAO,IAAIC,QAAQ,CAACC,EAASC,KAC3B,MAAMC,EAAiB,IAAIC,eAC3BD,EAAeE,MAAMC,UAAaC,IAChC,IAAKA,IAAUA,EAAMC,KAGnB,OAFAL,EAAeE,MAAMI,QACrBN,EAAeO,MAAMD,QACdP,EAAO,IAAIS,MAAMpB,KAAKC,MAAQ,0DAGvC,IAAIoB,EACJ,IACEA,EAAWC,KAAKC,MAAMP,EAAMC,MAC5B,MAAOO,GAIP,OAHAZ,EAAeE,MAAMI,QACrBN,EAAeO,MAAMD,QACrBlB,KAAKyB,cAAcD,GACZb,EAAOa,GAGZH,EAASK,MACXf,EAAOU,EAASK,YACaC,IAApBN,EAASO,OAClBlB,EAAQW,EAASO,QAEjBlB,IAEFE,EAAeE,MAAMI,QACrBN,EAAeO,MAAMD,SAGvB,IAAIW,EAAU,GACd,IACEA,EAAUP,KAAKQ,UAAU,CAACvB,UAASC,SACnC,MAAOgB,GACP,OAAOb,EAAO,IAAIS,MAAMpB,KAAKC,MAAQ,mEAEvC,IAAKD,KAAKF,oBACR,OAAOa,EAAO,IAAIS,MAAMpB,KAAKC,MAAQ,+BAEvCD,KAAKF,oBAAoBiC,YAAYF,EAAS,IAAK,CAACjB,EAAeO,UAI/D,eAAeH,GAErB,MAAMgB,EAAyBhB,EAAMiB,OAASC,MAAMC,QAAQnB,EAAMiB,QAAUjB,EAAMiB,MAAMG,OAAS,EAAKpB,EAAMiB,MAAM,GAAK,KACvH,GAAIjB,EAAMC,MAAQe,EAChB,IACE,MAAMH,EAA4BP,KAAKC,MAAMP,EAAMC,MACnD,IAAKjB,KAAKD,aACR,OAAOiC,EAASD,YAAYT,KAAKQ,UAAU,CAACJ,MAAO1B,KAAKC,MAAQ,sCAE7DiC,MAAMC,QAAQN,EAAQrB,QACzBqB,EAAQrB,KAAO,CAACqB,EAAQrB,OAE1B,MAAM6B,EAAarC,KAAKD,aAAa8B,EAASb,GAC9C,QAAmBW,IAAfU,EACF,OAGFA,EAAWC,KAAK,CAACrB,EAAY,MAE3B,IAAIS,OAAQC,EAERC,OAASD,EACO,kBAATV,GAA8B,OAATA,IAC9BS,EAAQT,EAAKS,MACbE,EAASX,EAAKW,QAGZF,EACFM,EAASD,YAAYT,KAAKQ,UAAU,CAACJ,gBACjBC,IAAXC,EACTI,EAASD,YAAYT,KAAKQ,UAAU,CAACF,YAErCI,EAASD,YAAYT,KAAKQ,UAAU,CAACF,OAAQX,MAE7CS,IACFM,EAASD,YAAYT,KAAKQ,UAAU,CAACJ,MAAO1B,KAAKyB,cAAcC,QAEjE,MAAOA,GACPM,EAASD,YAAYT,KAAKQ,UAAU,CAACJ,MAAO1B,KAAKyB,cAAcC,OAK7D,cAAcF,GACpB,GAAiB,kBAANA,EAAgB,CACzB,MAAME,EAAQ1B,KAAKC,MAAQ,KAAOuB,EAElC,OADAe,QAAQb,MAAMA,GACPA,EAIT,OAFAF,EAAEjB,QAAUP,KAAKC,MAAQ,KAAOuB,EAAEjB,QAClCgC,QAAQb,MAAMF,GACPA,EAAEjB","file":"js/chunk-2d22c2e4-legacy.11c1a807.js","sourcesContent":["import {Nullable} from '@/common/utils/types';\n\ninterface IncomingMessageBus {\n  addEventListener(type: 'message', listener: (this: Window, ev: WindowEventMap['message']) => any, options?: boolean | AddEventListenerOptions): void;\n}\n\ninterface OutgoingMessageBus {\n  postMessage: (message: any, targetOrigin: string, transfer?: Transferable[]) => void;\n}\n\ntype CommunicationSide = 'iframe' | 'website';\nexport type MessageExecutionResult = Promise<EmbeddingResponse> | undefined; // return undefined if a message was intercepted which belongs to another iframe\ntype MessageExecution = (message: EmbeddingCommand, event: MessageEvent) => MessageExecutionResult;\n\nexport interface EmbeddingResponse {\n  result?: any;\n  error?: string;\n}\n\nexport interface EmbeddingCommand {\n  message: string;\n  args: any[];\n}\n\nexport class MessageHandler {\n  private _side: CommunicationSide; // for better debugging (who handles message? iframe or website?)\n  private _incomingMessageBus: IncomingMessageBus;\n  private _outgoingMessageBus: Nullable<OutgoingMessageBus> = null;\n  private _execMessage: Nullable<MessageExecution> = null;\n\n  constructor(side: CommunicationSide, incomingMessageBus: IncomingMessageBus, outgoingMessageBus: Nullable<OutgoingMessageBus>, messageExecution: Nullable<MessageExecution>) {\n    this._side = side;\n    this._incomingMessageBus = incomingMessageBus;\n    this._outgoingMessageBus = outgoingMessageBus;\n    this._execMessage = messageExecution;\n    this._incomingMessageBus.addEventListener('message', this._handleMessage.bind(this));\n  }\n\n  public setOutgoingMessageBus(outgoingMessageBus: OutgoingMessageBus) {\n    this._outgoingMessageBus = outgoingMessageBus;\n  }\n\n  public setMessageExecution(fun: MessageExecution) {\n    this._execMessage = fun;\n  }\n\n  public sendMessage(message: string, args: any[] = []): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const messageChannel = new MessageChannel();\n      messageChannel.port1.onmessage = (event) => {\n        if (!event || !event.data) {\n          messageChannel.port1.close();\n          messageChannel.port2.close();\n          return reject(new Error(this._side + ' received message but response can not be interpreted'));\n        }\n\n        let response;\n        try {\n          response = JSON.parse(event.data) as EmbeddingResponse;\n        } catch (e) {\n          messageChannel.port1.close();\n          messageChannel.port2.close();\n          this._prepareError(e);\n          return reject(e);\n        }\n\n        if (response.error) {\n          reject(response.error);\n        } else if (response.result !== undefined) {\n          resolve(response.result);\n        } else {\n          resolve();\n        }\n        messageChannel.port1.close();\n        messageChannel.port2.close();\n      };\n\n      let command = '';\n      try {\n        command = JSON.stringify({message, args} as EmbeddingCommand);\n      } catch (e) {\n        return reject(new Error(this._side + ': can not create command because it is not JSON.stringify able'));\n      }\n      if (!this._outgoingMessageBus) {\n        return reject(new Error(this._side + ': outgoing bus not set yet'));\n      }\n      this._outgoingMessageBus.postMessage(command, '*', [messageChannel.port2]);\n    });\n  }\n\n  private _handleMessage(event: MessageEvent) {\n    // check if MessageEvent has a port set --> hope this clears confusion about https://developer.mozilla.org/en-US/docs/Web/API/Channel_Messaging_API/Using_channel_messaging\n    const receiver: MessagePort = (event.ports && Array.isArray(event.ports) && event.ports.length > 0) ? event.ports[0] : null;\n    if (event.data && receiver) {\n      try {\n        const command: EmbeddingCommand = JSON.parse(event.data);\n        if (!this._execMessage) {\n          return receiver.postMessage(JSON.stringify({error: this._side + ' is not ready to handle messages'} as EmbeddingResponse));\n        }\n        if (!Array.isArray(command.args)) {\n          command.args = [command.args];\n        }\n        const execResult = this._execMessage(command, event);\n        if (execResult === undefined) {\n          return; // do nothing because execMessage did not know what to do. Probably a message from another iframe was intercepted\n        }\n\n        execResult.then((data: any = {}) => {\n          // tslint:disable-next-line:no-unnecessary-initializer\n          let error = undefined;\n          // tslint:disable-next-line:no-unnecessary-initializer\n          let result = undefined;\n          if (typeof data === 'object' && data !== null) {\n            error = data.error;\n            result = data.result;\n          }\n\n          if (error) {\n            receiver.postMessage(JSON.stringify({error} as EmbeddingResponse));\n          } else if (result !== undefined) {\n            receiver.postMessage(JSON.stringify({result} as EmbeddingResponse));\n          } else {\n            receiver.postMessage(JSON.stringify({result: data} as EmbeddingResponse));\n          }\n        }, (error) => {\n          receiver.postMessage(JSON.stringify({error: this._prepareError(error)} as EmbeddingResponse));\n        });\n      } catch (error) {\n        receiver.postMessage(JSON.stringify({error: this._prepareError(error)} as EmbeddingResponse));\n      }\n    }\n  }\n\n  private _prepareError(e: Error | string) {\n    if (typeof e === 'string') {\n      const error = this._side + ': ' + e;\n      console.error(error);\n      return error;\n    }\n    e.message = this._side + ': ' + e.message;\n    console.error(e);\n    return e.message;\n  }\n\n}\n"],"sourceRoot":""}